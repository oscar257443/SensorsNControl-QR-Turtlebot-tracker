# SensorsNControl-QR-Turtlebot-tracker

## Individual Contribution
Quoc Minh Tran SID 12853305 40%

Oscar Gullickson SID 13558578  30%

Ben Thomas SID 13973108 30%


## Code Description
### Enviroment
#### Launch File

A launch file in ROS is a configuration file used to set up and launch various elements of a robot's simulation or operation. It typically begins with the `<launch>` tag, which defines its structure. Within a launch file, several key elements are used to configure parameters and execute tasks.

The `<arg>` elements play a significant role in setting parameters. For instance, you might use `<arg>` to specify the TurtleBot3 model type (e.g., "burger" or "waffle") via the "model" parameter. These elements can also define the X, Y, and Z-axis positions through parameters like "x_pos," "y_pos," and "z_pos."

Another important element is `<include>`. It allows you to include external ROS launch files to configure aspects of the environment. For instance, you might include "empty_world.launch" from the "gazebo_ros" package to configure the Gazebo simulation environment, providing various parameters.

The `<param>` element is used to set ROS parameters, like "robot_description." In this context, "robot_description" is generated by running the xacro command on a specific URDF Xacro file for the selected TurtleBot3 model, making the robot's model and description available for other components.

Lastly, the `<node>` element defines a ROS node responsible for spawning the TurtleBot3 robot model in the Gazebo simulation environment. It specifies various attributes such as the package ("gazebo_ros"), type ("spawn_model"), node name ("spawn_urdf"), and command-line arguments that provide the URDF description, model name, and position based on the previously defined parameters.

#### World File

The world file, marked by `<sdf version='1.7'>`, defines the properties of the simulated world. It starts with a `<world>` tag, named "default," encapsulating the world configuration.

Within the world file, several elements are crucial. First, the `<light>` element describes a light source named "sun" of type "directional," simulating sunlight. It specifies various attributes of the light, including its position, color, and shadow settings.

The `<model>` element defines models within the world. For example, "ground_plane" represents the ground or floor of the simulation and specifies its static nature, collision, and visual properties.

Gravity in the world is set using the `<gravity>` element, which defines a gravitational force in the z-direction, simulating Earth-like gravity.

The `<magnetic_field>` element defines the magnetic field in the simulation environment, including its strength in the x, y, and z directions.

The `<atmosphere>` element specifies the type of atmospheric model, which is "adiabatic" in this case, simplifying atmospheric effects.

The physics engine used for simulation is set via the `<physics>` element, with "ode" being a common choice. It also defines attributes like the maximum step size, real-time factors, and update rates.

Other elements include `<scene>` (scene settings), `<wind>` (presence of wind), and `<spherical_coordinates>` (global reference frame).

Furthermore, several `<model>` elements define the properties and attributes of objects within the simulation, such as their position, links, and properties. This includes models like "8x12," "Rickrolling_QR_code," and "unit_box."

Finally, the `<state>` element describes the state of the world, including simulation time and information about various models, lights, and cameras. The `<gui>` element defines GUI settings, including camera properties and projection type, for the simulation.

In summary, launch files and world files play crucial roles in configuring and defining both the robot and the simulation environment in ROS and Gazebo, respectively. These elements are essential for setting up and launching complex robotic simulations.

### Slam and Path Planning
Simultaneous Localisation and Mapping (SLAM) is a fundamental technique in robotics that involves the real-time mapping of an environment while simultaneously tracking the robot's position within that environment. In the context of this project, SLAM is crucial as it allows the Turtlebot, to create a map of its surroundings using the sensor data from the square's corners. The robot can use this map to understand its location in the coordinate frame and navigate effectively. Accurate SLAM ensures that the robot can follow a straight line perpendicular to the square with precision, even in the presence of observation noise. Without SLAM, the robot would struggle to make sense of its environment, and following a precise path would be challenging.

Path planning is the process of determining the best route for the robot to reach its desired destination within the mapped environment. In this project, path planning is essential to guide the robot along a straight line perpendicular to the square. It takes into account the information generated by SLAM to compute a path that avoids obstacles and noise-induced inaccuracies. Proper path planning ensures that the robot can navigate the environment with precision and efficiency, ensuring it follows the desired route. The combination of SLAM and path planning is pivotal to the project's success, allowing the robot to achieve its goal of following a straight line with accuracy, even with sensor noise.

### Slam Commands
Slam and path planning Commands

export TURTLEBOT3_MODEL=waffle
roslaunch turtlebot3_gazebo SnC.launch

export TURTLEBOT3_MODEL=waffle
roslaunch turtlebot3_slam turtlebot3_slam.launch slam_methods:=hector

export TURTLEBOT3_MODEL=waffle
roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch

rosrun map_server map_saver -f ~/SnC	//to save map 

CLOSE ALL

### Path Planning Commands

export TURTLEBOT3_MODEL=waffle
roslaunch turtlebot3_gazebo SnC.launch

export TURTLEBOT3_MODEL=waffle
roslaunch turtlebot3_navigation turtlebot3_navigation.launch map_file:=$HOME/SnC.yaml

//set initial pose using 2D Pose estimate button

export TURTLEBOT3_MODEL=waffle
roslaunch turtlebot3_teleop turtlebot3_teleop_key.launch

//move around to get good data

//close the telop with CTRL + C

//Set Nav Goal using 2D Nav Goal button

### Python scripts
There is a total of 4 python scripts. 
I created 3 pieces of code that each served a difference purpose and then integrated them into a singular functional piece of code, called TurtlebotVisualServoing.py, that combined the 3.  This code does not function as one of the subcodes was not able to be completed , Visual servoing, in time for submission therefore the control systems are not working.

The sub codes are VisualServoing.py, VisualCode.py, and ROS2CV2.py. 

The ROS2CV2.py  involved subscribe the camera data and importing it to the python environment for further processing. This is working as intended

The VisualCode.py involved creating a publishing node that gives the next position for the robot to move to in the visual servoing method. This works by creating a rostopic and node and transforming a x y theta input to the function to the posestamp format desired by the rospackage. We also have to change the euler angle to a quaternion format in order to meet the requirements of the format. Then we publish the goal and the path planning works as intended. This is working as intended.

The VisualServoing.py this part I worked on was the detection and then visual servoing. This grabs the images then proceeds to use orb feature detection and brute force matching to get matching pair. Then we filter the pair in order to get the good pairs. This is where we stop as we wasnt able to perform the calculations due to python inexperience combined with lack of time remaining 

Required packages for the python scripts:
    pip install roslibpy
    pip install opencv-python==4.7.0.68
